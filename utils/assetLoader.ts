
/**
 * Utility for robust static asset loading in an offline-first environment.
 * Handles path resolution across different hosting environments.
 */

export interface LoadResult {
  ok: boolean;
  loadedFrom: string;
  json?: any;
  pathsTried: string[];
  error?: string;
  statusCode?: number;
}

interface AutoLoadOptions {
  dateStrings: string[];
  defaultName: string;
}

export const resolveAssetUrl = (path: string): string => {
  try {
    const base = document.baseURI || window.location.href;
    const url = new URL(path, base).href;
    return url;
  } catch (e) {
    return path;
  }
};

/**
 * Sanitizes non-standard JSON tokens like NaN or Infinity before parsing.
 * Essential for pipeline artifacts generated by Python/Pandas.
 */
const safeJsonParse = (text: string): any => {
  const sanitized = text
    .replace(/\bNaN\b/g, 'null')
    .replace(/\b-?Infinity\b/g, 'null');
  return JSON.parse(sanitized);
};

export const autoLoadReferencePack = async (options: AutoLoadOptions): Promise<LoadResult> => {
  const { dateStrings, defaultName } = options;
  
  const baseNames = ['pipeline_latest'];
  dateStrings.forEach(ds => baseNames.push(`pipeline_${ds}`));
  if (!baseNames.includes(defaultName)) baseNames.push(defaultName);

  const prefixes = ['test_data/', '/test_data/', './test_data/', '../test_data/'];
  const candidates: string[] = [];

  prefixes.forEach(pre => {
    baseNames.forEach(name => {
      candidates.push(`${pre}${name}.json`);
    });
  });

  const uniqueCandidates = Array.from(new Set(candidates));
  const pathsTried: string[] = [];
  let lastError = '';
  let lastStatus = 0;

  console.group('üìÇ SlateSavvy Asset Discovery');
  console.log('Initiating deterministic search for pipeline artifacts...');

  for (const path of uniqueCandidates) {
    const url = resolveAssetUrl(path);
    pathsTried.push(url);
    
    try {
      console.log(`Checking path: ${url}`);
      const res = await fetch(url, { cache: 'no-store' });
      
      if (res.ok) {
        // Fetch as text to handle NaN/Infinity sanitization
        const text = await res.text();
        const json = safeJsonParse(text);
        console.log(`%c‚úÖ FOUND: ${url}`, 'color: #10b981; font-weight: bold;');
        console.groupEnd();
        return { ok: true, loadedFrom: url, json, pathsTried };
      } else {
        lastStatus = res.status;
        console.warn(`Miss (${res.status}): ${url}`);
      }
    } catch (e: any) {
      lastError = e.message;
      console.error(`Network Error for ${url}:`, e);
    }
  }

  console.error('‚ùå DISCOVERY FAILED: No valid pipeline JSON found in candidates.');
  console.groupEnd();

  return { 
    ok: false, 
    loadedFrom: '', 
    pathsTried, 
    statusCode: lastStatus,
    error: lastError || `Auto-load failed. Tried ${uniqueCandidates.length} potential locations.` 
  };
};
